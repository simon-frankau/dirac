; Basic test program to exercise my simple Z80-based computer.
;
; TODO: Currently just a copy of the cylon thing. Needs fleshing out
;
; PLAN:
; X Do a few flashing lights initially
; X Enable memory banking for the ROM location
; X Flash a few more lights to show still working
; X Map RAM in for stack space
; X Flash a few more lights, making use of stack
; * Then we want to test the banking hardware, specifically:
; ** Can write and read all values to all locations (skip top and bottom)
; ** Can map all locations into one of the slots, and fill with data...
; ** Then map all locations into another slot, and read all the data
; ** Probably want to check that read-only mappings allow reading, do not
;    allow writing.
; * Should also have an NMI-tester

; Need some kind of assumption about where the LEDs and banking are
; mapped...

; Banking    is at port 0x00.
; LED output is at port 0x70.

; Banked memory map:
; 0x00000 - 0x07FFF - ROM (top 4 bits inverted when programming the EEPROM)
; 0x80000 - 0x9FFFF - RAM - Read-only
; 0xC0000 - 0xDFFFF - RAM - Read-write

; Simple cylon/knightrider thing
; Dumbest possible implementation - no dependency on RAM, can just be dropped
; in at 0x0000.

#target     rom

#code       0,$4000

; Initial wipe across, no hardware enabled

top:        ld a,$1
            out ($70),a

            ld de,0
l1:         dec de
            ld a, d
            or e
            jp nz, l1

            ld a,$2
            out ($70),a

            ld de,0
l2:         dec de
            ld a, d
            or e
            jp nz, l2

            ld a,$4
            out ($70),a

            ld de,0
l3:         dec de
            ld a, d
            or e
            jp nz, l3

            ld a,$8
            out ($70),a

            ld de,0
l4:         dec de
            ld a, d
            or e
            jp nz, l4

            ld a,$10
            out ($70),a

            ld de,0
l5:         dec de
            ld a, d
            or e
            jp nz, l5

            ld a,$20
            out ($70),a

            ld de,0
l6:         dec de
            ld a, d
            or e
            jp nz, l6

            ld a,$40
            out ($70),a

            ld de,0
l7:         dec de
            ld a, d
            or e
            jp nz, l7

            ld a,$80
            out ($70),a

; Enable banking

            ld bc, $0000
            ld a, $00 ; Inverted, selects the default $FF page
            out (bc), a

; And do a few more LEDs

            ld de,0
l8:         dec de
            ld a, d
            or e
            jp nz, l8

            ld a,$40
            out ($70),a

            ld de,0
l9:         dec de
            ld a, d
            or e
            jp nz, l9

            ld a,$20
            out ($70),a

            ld de,0
l10:        dec de
            ld a, d
            or e
            jp nz, l10

            ld a,$10
            out ($70),a

            ld de,0
l11:        dec de
            ld a, d
            or e
            jp nz, l11

            ld a,$8
            out ($70),a

            ld de,0
l12:        dec de
            ld a, d
            or e
            jp nz, l12

            ld a,$4
            out ($70),a

            ld de,0
l13:        dec de
            ld a, d
            or e
            jp nz, l13

            ld a,$2
            out ($70),a

            ld de,0
l14:        dec de
            ld a, d
            or e
            jp nz, l14

; Map in some RAM, set SP, and do a pattern with using subroutines

            ld bc, $f000
            ld a, $c0 ; Inverted, selects a RAM page, RW
            out (bc), a

            ld sp, $0000

loop:       ld a, $03
            call disp
            ld a, $06
            call disp
            ld a, $0c
            call disp
            ld a, $18
            call disp
            ld a, $30
            call disp
            ld a, $60
            call disp
            ld a, $c0
            call disp
            ld a, $81
            call disp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Right, the basics work: ROM mapped in page 0x0, RAM mapped in page 0xf
;
; Now, check the mapping slots we can:
; For each value, write different values to all available slots,
; then read them back.

; For each number:
            ld d, 0
blah0:      ld c, 0      ; Lower part of port.

; Write a different number to each slot
            ld l, d      ; Base value to write
            ld b, $e0    ; Last page to write
blah1:      out (bc), l  ; Write page thing
            inc l        ; Write next value to next page
            ld a, b
            sub a, $10   ; Next page
            ld b, a
            jp nz, blah1 ; Don't write page zero
; Read back numbers and check it's ok
            ld l, d      ; Thing to compare against
            ld b, $e0    ; Last page to write
blah2:      in a, (c)    ; Read page thing (NB: Really 'in a, (bc)')
            cp l
            jp nz, fail
            inc l        ; Read next value from next page
            ld a, b
            sub a, $10   ; Next page
            ld b, a
            jp nz, blah2 ; Don't read page zero

            dec d
            jp nz, blah0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Slots all work. Let's assume the ROM works, as a I don't want
; to bother testing it, beyond showing that we're reading the test ok.
; Let's map a single slot, and use it to write over all of RAM, then
; read it all back.

; NB: This corrupts stack. Fortunately, not actually using it...

            ld l, 23         ; Magic modulo.
; Map physical pages C0-DF into slot 1.
            ld h, $c0
ramwouter:  ld bc, $1000
            out (bc), h
; Loop from $2000 to $1000, scribbling values in as we go.
            ld de,$2000
ramwinner:  ld a, l
            ld (de), a
            dec l
            jp nz, rwiskip
            ld l,23
rwiskip:    dec de
            ld a, d
            sub 1
            or e
            jp nz, ramwinner
; Written this page, go to next.
            inc h
            ld a, h
            cp a, $e0
            jp nz, ramwouter
            
; TODO: Having written, read back.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; FIXME: Things not otherwise checked:
;  * Read-only RAM
;  * ROM access
;  * NMI

success:    ld a, $ff
            call disp
            ld a, $ff
            call disp
            jp success

fail:       ld a, $aa
            call disp
            jp fail

disp:       out ($70),a

            ld de,0
disp_loop:  dec de
            ld a, d
            or e
            jp nz, disp_loop
            ret

#end
